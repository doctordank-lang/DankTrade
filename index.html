<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Vibe Survivor</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: radial-gradient(circle at center, #020617, #000);
    overflow: hidden;
    font-family: system-ui, sans-serif;
    color: white;
  }

  #hud {
    position: fixed;
    top: 20px;
    left: 20px;
    font-size: 18px;
    opacity: 0.9;
  }

  #gameover {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    background: rgba(0,0,0,0.7);
    font-size: 28px;
  }

  button {
    margin-top: 20px;
    padding: 10px 20px;
    font-size: 18px;
    cursor: pointer;
  }

  canvas { display: block; }
</style>
</head>
<body>

<div id="hud">
  Score: <span id="score">0</span><br>
  Misses: <span id="misses">0</span>/5
</div>

<div id="gameover">
  <div id="finalScore"></div>
  <button onclick="restart()">Play Again</button>
</div>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const scoreEl = document.getElementById("score");
const missesEl = document.getElementById("misses");
const gameoverEl = document.getElementById("gameover");
const finalScoreEl = document.getElementById("finalScore");

let score = 0;
let misses = 0;
let orbs = [];
let spawnRate = 1200;
let running = true;

// Resize
function resize() {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
addEventListener("resize", resize);
resize();

// Audio
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function blip(freq) {
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.frequency.value = freq;
  g.gain.value = 0.001;
  g.gain.exponentialRampToValueAtTime(0.2, audioCtx.currentTime + 0.01);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
  o.connect(g);
  g.connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + 0.25);
}

// Orb spawn
function spawnOrb() {
  if (!running) return;

  const life = Math.max(800 - score * 10, 300);

  orbs.push({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    r: 30,
    born: performance.now(),
    life
  });

  spawnRate = Math.max(300, spawnRate - 5);
  setTimeout(spawnOrb, spawnRate);
}
spawnOrb();

// Click detection
canvas.addEventListener("pointerdown", e => {
  if (audioCtx.state === "suspended") audioCtx.resume();

  const x = e.clientX;
  const y = e.clientY;

  for (let i = orbs.length - 1; i >= 0; i--) {
    const o = orbs[i];
    const d = Math.hypot(o.x - x, o.y - y);
    if (d < o.r) {
      orbs.splice(i, 1);
      score++;
      scoreEl.textContent = score;
      blip(300 + score * 4);
      return;
    }
  }
});

// Game loop
function loop(t) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  orbs.forEach((o, i) => {
    const age = t - o.born;
    const pct = age / o.life;

    if (pct >= 1) {
      orbs.splice(i, 1);
      misses++;
      missesEl.textContent = misses;
      blip(100);
      if (misses >= 5) endGame();
      return;
    }

    // Orb
    ctx.beginPath();
    ctx.arc(o.x, o.y, o.r, 0, Math.PI * 2);
    ctx.fillStyle = `hsl(${score * 8 % 360}, 80%, 60%)`;
    ctx.fill();

    // Timer ring
    ctx.strokeStyle = "white";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(o.x, o.y, o.r + 6, -Math.PI/2,
      -Math.PI/2 + Math.PI * 2 * (1 - pct));
    ctx.stroke();
  });

  if (running) requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// End / Restart
function endGame() {
  running = false;
  finalScoreEl.textContent = "Final Score: " + score;
  gameoverEl.style.display = "flex";
}

function restart() {
  score = 0;
  misses = 0;
  orbs = [];
  spawnRate = 1200;
  running = true;
  scoreEl.textContent = 0;
  missesEl.textContent = 0;
  gameoverEl.style.display = "none";
  spawnOrb();
  requestAnimationFrame(loop);
}
</script>

</body>
</html>
